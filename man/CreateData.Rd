% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/randomEffects-actor.R
\name{CreateData}
\alias{CreateData}
\title{Create data for Stan}
\usage{
CreateData(
  randomEffects,
  fixedEffects,
  model = c("DyNAM", "REM"),
  subModel = c("choice", "rate", "choice_coordination"),
  supportConstraint = NULL,
  preprocessArgs = NULL,
  progress = getOption("progress")
)
}
\arguments{
\item{randomEffects}{a \code{list}, each component is a \code{formula} and represents a
random effect to include in the model. Each \code{formula} has on the left hand
side the effect specification that plays the role of random effect, and
on the right hand side effects that would explain the variability of that
random effect.}

\item{fixedEffects}{a \code{formula} specification as in \code{\link[goldfish:estimate]{goldfish::estimate()}}.
The effects include in the right hand side play the role of fixed effects in
the model.}

\item{model}{Current version only support \code{"DyNAM"} model, enhancements
on the code would allow to use \code{"REM"} model too.}

\item{subModel}{Current version only support \code{"choice"} sub-model.}

\item{supportConstraint}{a \code{formula} with only an effect that gives the
information of the restricted set to consider.
In the case of the \code{"choice"} sub-model, it corresponds to the choice set
available to received an event at each moment of time.
In the case of the \code{"rate"} sub-model, it corresponds to the competing set
available to send an event at each moment of time.
In the case of the \code{"REM"} model, it corresponds to the set of dyads
available to create an event at each moment of time.
The left hand side of the formula is left empty.
The effect should be coded in such a way that value 1 indicated
the availability and 0 the absence.
In the case that some actors left or join the process at any point of time is
better to use the \code{present} variable in the node data frame linking to it the
time varying changes of composition of the actors set.}

\item{preprocessArgs}{a list with additional preprocess arguments used by
\code{\link[goldfish:GatherPreprocessing]{goldfish::GatherPreprocessing()}} to compute the changes statistics of the
event sequence.}

\item{progress}{logical argument passed to \code{\link[goldfish:GatherPreprocessing]{goldfish::GatherPreprocessing()}}
to show the progress of the preprocessing of the events sequence.}
}
\value{
an object of class \code{"goldfish.latent.data"} that contains
a list with the following components.
\describe{
\item{dataStan}{a list with the information necessary to run a HMC using
Stan.}
\item{sendersIx}{a data frame with the label of the sender from the
nodes data frame, and the index assign to the random coefficient.}
\item{namesEffects}{a character vector with terms in the random and fixed
effects formulas and their final name.}
\item{effectDescription}{an array with detailed and comprehensible
information of the terms used in the random and fixed effects formulas.}
}
}
\description{
The first step is create the data in the structure expected by the \code{Stan}
code designed for the DyNAM with actor random effects.
Additional information of the effects used during preprocessing is added to
the return object.
}
\details{
The model formulation is composed of two parts: the fixed effect part
\code{fixedEffects} and the random effect part \code{randomEffects}.
The fixed effect formulation works as the formulation of models in \code{goldfish}.
All the effects used here in the right hand side are considered to be fixed,
hence, they won't have random effects.
The random effects formulation considers the possibility to have more than
one random effect, and that every random effect might be explain by actors'
monadic statistics or covariates.
A formula like \code{effect(network) ~ egoAlterInt(list(attrEgo, attrAlter))}
indicates that the \code{effect(network)} is added to the model having
random effects and those could be explain by the effects included on the
right hand side.
}
\examples{
\donttest{
library(goldfish)
data("Social_Evolution")
callNetwork <- defineNetwork(nodes = actors, directed = TRUE) |>
  linkEvents(changeEvent = calls, nodes = actors)
callsDependent <- defineDependentEvents(
  events = calls, nodes = actors, defaultNetwork = callNetwork
)
data2stan <- CreateData(
  randomEffects = list(inertia ~ 1),
  fixedEffects = callsDependent ~ recip + trans
)
}
}
