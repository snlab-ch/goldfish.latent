% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HMM.R
\name{HMMPostProcessing}
\alias{HMMPostProcessing}
\title{Post process MCMC samples from a HMM}
\usage{
HMMPostProcessing(
  data2Stan,
  cmdstanSamples,
  kRegimes = data2Stan$dataStan$kR,
  type = c("both", "viterbi", "smoothProbs"),
  smoothProbsSt = c("joint", "marginal", "none")
)
}
\arguments{
\item{data2Stan}{a object of class \code{"goldfish.latent.data"} outcome of a call
to \code{\link[=CreateDataHMM]{CreateDataHMM()}}.}

\item{cmdstanSamples}{a object of class \code{"CmdStanMCMC"} with the posterior
samples of a HMM from the \code{data2Stan}.}

\item{kRegimes}{an integer with the number of states used to get samples
from the posterior distribution in \code{cmdstanSamples}.}

\item{type}{a character specifying which algorithm to use for the post
processing of the posterior distribution samples.}

\item{smoothProbsSt}{a character specifying the way that state sample path
are drawn either using the smoothed probabilities \code{"marginal"} or
conditioning of the next sample state \code{"joint"}.
Only used when \code{type = "both"} or \code{type = "smoothProbs"}.}
}
\value{
a list with the most probable path when Viterbi algorithm is used
and/or the smoothed probabilities and sample paths when the
Forward-Backward algorithm is used.
}
\description{
The post-processing allows to compute for each posterior draw:
the most probable path of the Hidden States using the Viterbi algorithm,
the smoothed probabilities of a Hidden State given the observed sequence
using the Forward-Backward algorithm, and a sample path using the smoothed
probabilities \code{smoothProbsSt = "marginal"} or taking into account the
conditional probability given the next state  \code{smoothProbsSt = "joint"} as
implemented in Stan \code{hmm_latent_rng()}.
}
\examples{
\donttest{
library(goldfish)
data("Social_Evolution")
callNetwork <- defineNetwork(nodes = actors, directed = TRUE) |>
  linkEvents(changeEvent = calls, nodes = actors)
callsDependent <- defineDependentEvents(
  events = calls, nodes = actors, defaultNetwork = callNetwork
)
data2stan <- CreateDataHMM(
  rateEffects = callsDependent ~ indeg + outdeg,
  choiceEffects = NULL
)

postProcess <- HMMPostProcessing(data2stan, cmdstanSamples)
}
}
